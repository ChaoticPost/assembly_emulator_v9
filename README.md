# Эмулятор одноадресного процессора с архитектурой Фон-Неймана

[![GitHub](https://img.shields.io/badge/GitHub-Repository-blue)](https://github.com/ChaoticPost/assembly_emulator_v9)
[![Version](https://img.shields.io/badge/Version-9.0.0-green)](https://github.com/ChaoticPost/assembly_emulator_v9)

## Описание проекта

Данный проект представляет собой полнофункциональный веб-эмулятор одноадресного процессора с архитектурой Фон-Неймана. Эмулятор реализует систему команд с фиксированной длиной, поддерживает различные режимы адресации и включает в себя ассемблер для компиляции исходного кода в машинные инструкции.

### Основные возможности

- **Полная эмуляция одноадресного процессора** - реализация одноадресной архитектуры с одним аккумулятором (ACC)
- **Архитектура Фон-Неймана** - единая память для команд и данных
- **Ассемблер** - двухпроходная компиляция с поддержкой меток и различных форматов чисел
- **Веб-интерфейс** - современный React-интерфейс с визуализацией состояния процессора
- **Пошаговое выполнение** - возможность выполнять программу пошагово для отладки с фазами FETCH, DECODE, EXECUTE
- **Предустановленные задачи** - готовые задачи для тестирования и обучения
- **REST API** - полный набор endpoints для управления эмулятором
- **Docker поддержка** - легкий запуск через Docker Compose

---

## Архитектура процессора

### Основные характеристики

- **Тип архитектуры:** Одноадресная архитектура Фон-Неймана
- **Разрядность:** 16-битный аккумулятор, 16-битные команды
- **Память:** 8192 ячеек по 16 бит (адреса 0x0000-0x1FFF)
- **Регистры:** Один аккумулятор (ACC) для всех операций
- **Формат команд:** Команды с одним операндом (ACC + операнд)
- **Архитектура Фон-Неймана:** Единая память для команд и данных

### Регистры процессора

| Регистр | Назначение | Разрядность |
|---------|-----------|-------------|
| **ACC** | Аккумулятор (единственный регистр для всех операций) | 16 бит |
| **PC** | Счетчик команд (Program Counter) | 16 бит |
| **IR** | Регистр команд (Instruction Register) | 16 бит |

**Особенности одноадресной архитектуры:**
- Все арифметические и логические операции выполняются через аккумулятор
- Результат операции всегда сохраняется в аккумуляторе
- Для работы с данными используется прямая адресация памяти
- Косвенная адресация недоступна, используется таблица переходов для доступа к массивам

### Флаги состояния

Процессор поддерживает 4 флага состояния, которые устанавливаются после выполнения арифметических и логических операций:

- **Z (Zero)** - флаг нуля: устанавливается в 1, если результат операции равен нулю
- **C (Carry)** - флаг переноса: устанавливается при переполнении при сложении/вычитании
- **V (Overflow)** - флаг переполнения: устанавливается при выходе результата за пределы 16-битного диапазона (-32768..32767)
- **N (Negative)** - флаг знака: устанавливается в 1, если результат отрицательный

---

## Система команд

### Формат команд

Процессор использует одноадресную систему команд, где все операции выполняются через аккумулятор (ACC):

- **Все команды имеют формат:** `КОМАНДА операнд`
- **Результат всегда сохраняется в ACC**
- **Операнд может быть:** непосредственным значением, адресом памяти или меткой

### Структура команды

```
Формат команды одноадресного процессора:
┌─────────────────────────────────────────┐
│ OPCODE (8 бит) │ ОПЕРАНД (16 бит)      │
└─────────────────────────────────────────┘

Примеры:
- LDA 0x0100    - загрузка из памяти
- LDI 100       - загрузка константы
- ADD 0x0200    - сложение с памятью
- STA 0x0300    - сохранение в память
```

**Особенности:**
- Код операции (OPCODE) - 8 бит
- Операнд - 16 бит (адрес памяти или непосредственное значение)
- Все операции выполняются с участием аккумулятора

### Режимы адресации

Процессор поддерживает следующие режимы адресации:

| Режим | Описание | Пример |
|-------|----------|--------|
| Непосредственная | Значение указано в команде | `LDI 100` |
| Прямая | Адрес указан в команде (hex или в скобках) | `LDA 0x0100` или `LDA [0x0100]` |
| Прямая (метка) | Использование меток для переходов | `JMP LOOP_START` |

**Ограничения:**
- Косвенно-регистровая адресация недоступна (нет регистров-указателей)
- Для работы с массивами используется таблица переходов на основе индекса

---

## Справочник команд

### Арифметико-логические операции

| Команда | Код | Формат | Описание |
|---------|-----|--------|----------|
| `ADD` | 0x01 | `ADD addr` | Сложение: ACC = ACC + память[addr] |
| `SUB` | 0x02 | `SUB addr` | Вычитание: ACC = ACC - память[addr] |
| `MUL` | 0x03 | `MUL addr` | Умножение: ACC = ACC * память[addr] |
| `DIV` | 0x04 | `DIV addr` | Деление: ACC = ACC / память[addr] |
| `AND` | 0x05 | `AND addr` | Логическое И: ACC = ACC & память[addr] |
| `OR` | 0x06 | `OR addr` | Логическое ИЛИ: ACC = ACC \| память[addr] |
| `XOR` | 0x07 | `XOR addr` | Исключающее ИЛИ: ACC = ACC ^ память[addr] |
| `NOT` | 0x08 | `NOT` | Логическое НЕ: ACC = ~ACC |

**Особенности:**
- Все операции устанавливают флаги Z, N, V, C
- При делении на ноль генерируется ошибка
- Переполнение отслеживается для 16-битных значений
- Результат всегда сохраняется в аккумуляторе (ACC)

### Команды пересылки данных

| Команда | Код | Формат | Описание |
|---------|-----|--------|----------|
| `LDA` | 0x10 | `LDA addr` | Загрузка из памяти: ACC = память[addr] |
| `STA` | 0x11 | `STA addr` | Сохранение в память: память[addr] = ACC |
| `LDI` | 0x12 | `LDI imm` | Загрузка константы: ACC = immediate |

**Форматы чисел:**
- Десятичное: `100`, `-50`
- Шестнадцатеричное: `0x1000`, `0xFF`
- Двоичное: `0b1010`

**Примеры:**
```assembly
LDI 100        ; ACC = 100
LDA 0x0100     ; ACC = память[0x0100]
STA 0x0200     ; память[0x0200] = ACC
```

### Команды сравнения и переходов

| Команда | Код | Формат | Описание |
|---------|-----|--------|----------|
| `CMP` | 0x20 | `CMP addr` | Сравнение: устанавливает флаги (ACC - память[addr]) |
| `JMP` | 0x21 | `JMP addr` | Безусловный переход |
| `JZ` | 0x22 | `JZ addr` | Переход если Z=1 (результат равен нулю) |
| `JNZ` | 0x23 | `JNZ addr` | Переход если Z=0 (результат не равен нулю) |
| `JC` | 0x24 | `JC addr` | Переход если C=1 (есть перенос/заем) |
| `JNC` | 0x25 | `JNC addr` | Переход если C=0 (нет переноса/заема) |
| `JV` | 0x26 | `JV addr` | Переход если V=1 (есть переполнение) |
| `JNV` | 0x27 | `JNV addr` | Переход если V=0 (нет переполнения) |
| `JN` | 0x28 | `JN addr` | Переход если N=1 (результат отрицательный) |
| `JNN` | 0x29 | `JNN addr` | Переход если N=0 (результат неотрицательный) |

**Особенности переходов:**
- Адрес может быть меткой или числом
- При переходе PC устанавливается на указанный адрес
- После перехода выполнение продолжается с нового адреса
- `CMP` не изменяет значение ACC, только устанавливает флаги

### Системные команды

| Команда | Код | Формат | Описание |
|---------|-----|--------|----------|
| `HALT` | 0xFF | `HALT` | Остановка выполнения программы |
| `NOP` | 0x00 | `NOP` | Нет операции (задержка) |

---

## Предустановленные задачи

### Задача 1: Поиск максимума в массиве

**Описание:** Найти максимальный элемент в массиве целых чисел без знака и сохранить результат в аккумуляторе (ACC). Алгоритм поддерживает массивы размером от 1 до 15 элементов. Для быстрой проверки используется упрощенный пример с массивом из 3 элементов.

**Входные данные:**
- Массив: `[3, 10, 20, 30]` (для примера с автоматической загрузкой данных)
- Формат: первый элемент - размер массива (3), далее - элементы массива
- Массив хранится в памяти начиная с адреса `0x0100`
  - `[0x0100]` = размер массива (3)
  - `[0x0101]` = первый элемент (10)
  - `[0x0102]` = второй элемент (20)
  - `[0x0103]` = третий элемент (30)

**Ожидаемый результат:** `30` (максимальный элемент в аккумуляторе ACC)

**Варианты использования:**
- **Пример:** Код с автоматической загрузкой данных из бэкенда (массив [3, 10, 20, 30])
- **Шаблон:** Код с ручной инициализацией массива (можно изменить значения элементов)

**Особенности:**
- Использование цикла с командами `CMP`, `JZ`, `JMP`, `JC`
- Таблица переходов для доступа к элементам массива (косвенная адресация недоступна)
- Сравнение беззнаковых чисел с использованием флага переноса (Carry)
- Инкремент индекса и проверка условия выхода из цикла
- **Упрощенный код для примера:** программа оптимизирована для массива из 3 элементов (индексы 2 и 3)
- **Автоматическая загрузка данных:** при выборе "Пример" данные задачи автоматически загружаются из бэкенда
- **Постепенная загрузка данных:** данные массива появляются в RAM постепенно, по одному элементу за каждую команду execute (начиная с первого execute)
- **Отображение с адресами:** в интерфейсе данные отображаются в формате `[0x0100]=0x0003` (hex) и `[0x0100]=3` (dec)
- **Отображение максимума:** переменная максимума (адрес 0x0411) отображается на каждом шаге выполнения

**Алгоритм:**
1. Инициализация: первый элемент (10) становится начальным максимумом
2. Загрузка размера массива из памяти `[0x0100]` (размер = 3)
3. Инициализация индекса i = 2 (начинаем со второго элемента)
4. Цикл: пока индекс <= размер
   - Загрузка элемента массива по индексу через таблицу переходов
     - Индекс 2: загрузка элемента [0x0102] = 20
     - Индекс 3: загрузка элемента [0x0103] = 30
   - Сравнение элемента с текущим максимумом через `CMP`
   - Если элемент > максимума (флаг Carry установлен), обновить максимум
   - Увеличение индекса
5. Результат в ACC (максимальный элемент = 30)

**Для примера с 3 элементами:**
- Шаг 1: максимум = 10 (первый элемент)
- Шаг 2: сравнение с элементом 20 → максимум обновляется до 20
- Шаг 3: сравнение с элементом 30 → максимум обновляется до 30
- Результат: ACC = 30

### Задача 2: Свертка двух массивов

**Описание:** Вычислить свертку (скалярное произведение) двух массивов по 10 элементов каждый.

**Входные данные:**
- Массив A: `[2, 3, 1, 4, 5, 2, 3, 1, 4, 2]` (адреса 0x0200-0x020A)
  - `[0x0200]` = размер массива (10)
  - `[0x0201]` = A[0] (2)
  - `[0x0202]` = A[1] (3)
  - и т.д.
- Массив B: `[1, 2, 3, 1, 2, 3, 1, 2, 3, 1]` (адреса 0x0300-0x030A)
  - `[0x0300]` = размер массива (10)
  - `[0x0301]` = B[0] (1)
  - `[0x0302]` = B[1] (2)
  - и т.д.

**Ожидаемый результат:** `50` (в аккумуляторе ACC)

**Формула:** Σ(A[i] * B[i]) для i=1..10 (индекс начинается с 1, так как [0x0200] и [0x0300] - размеры)

**Особенности:**
- Работа с двумя массивами одновременно
- Использование команды `MUL` для умножения элементов
- **Архитектура фон Неймана:** команды программы хранятся в RAM начиная с адреса `0x0000`
- **Постепенная загрузка данных:** данные массивов A и B появляются в RAM постепенно, по одному элементу за каждую команду execute
- **Отображение команд и данных:** в интерфейсе отображаются команды из RAM (0x0000-0x00FF) и данные массивов (0x0200-0x020A, 0x0300-0x030A) с адресами
- **Таблица переходов:** для доступа к элементам массивов используется таблица переходов на основе индекса (косвенная адресация недоступна)

**Алгоритм:**
1. Инициализация: ACC = 0 (аккумулятор), индекс = 1 (хранится в памяти)
2. Загрузка размера массивов из памяти `[0x0200]`
3. Цикл: для i от 1 до размера
   - Загрузка A[i] из памяти через таблицу переходов по индексу
   - Сохранение A[i] во временную переменную
   - Загрузка B[i] из памяти через таблицу переходов по индексу
   - Умножение A[i] * B[i] (результат в ACC)
   - Добавление произведения к сумме (сумма хранится в ACC)
   - Увеличение индекса
4. Результат в ACC

---

## Техническая структура

### Backend (Python/FastAPI)

```
backend/
├── app/
│   ├── __init__.py
│   ├── main.py              # FastAPI приложение и API endpoints
│   ├── models.py            # Pydantic модели данных
│   ├── processor.py         # RISC процессор (эмуляция выполнения)
│   ├── assembler.py         # Ассемблер (компиляция кода)
│   ├── emulator.py          # Основной эмулятор (координация)
│   └── tasks.py             # Предустановленные задачи
├── requirements.txt         # Python зависимости
└── Dockerfile              # Docker образ для backend
```

**Технологии:**
- Python 3.8+
- FastAPI 0.104.1
- Pydantic 2.5.0
- Uvicorn 0.24.0

**Основные компоненты:**

1. **RISCProcessor** (`processor.py`) - эмуляция одноадресного процессора:
   - Выполнение команд одноадресной архитектуры
   - Управление аккумулятором (ACC) и памятью
   - Обновление флагов состояния (Z, C, V, N)
   - Пошаговое выполнение с фазами FETCH, DECODE, EXECUTE

2. **RISCAssembler** (`assembler.py`) - компилятор:
   - Двухпроходная компиляция
   - Парсинг команд и операндов
   - Обработка меток
   - Генерация машинного кода

3. **RISCEmulator** (`emulator.py`) - координатор:
   - Управление состоянием эмулятора
   - Загрузка и выполнение программ
   - Работа с задачами
   - Верификация результатов

### Frontend (React/TypeScript)

```
frontend/
├── src/
│   ├── components/
│   │   ├── CommandEditor/   # Редактор команд с подсветкой
│   │   ├── ControlPanel/    # Панель управления (шаг/выполнить/сброс)
│   │   ├── MemoryView/      # Просмотр памяти и истории
│   │   ├── ProcessorView/   # Отображение процессора (регистры, флаги, PC)
│   │   ├── TaskPanel/       # Панель задач
│   │   ├── ErrorDisplay/    # Отображение ошибок
│   │   └── TechStack/       # Информация о технологиях
│   ├── services/
│   │   └── api.ts           # API клиент (HTTP запросы)
│   ├── store/
│   │   └── emulatorStore.ts # Zustand store (управление состоянием)
│   ├── types/
│   │   └── emulator.ts      # TypeScript типы
│   ├── App.tsx              # Главный компонент
│   └── main.tsx             # Точка входа
├── package.json
├── vite.config.ts
└── Dockerfile
```

**Технологии:**
- React 19.1.1
- TypeScript 5.8.3
- Vite 5.0.0
- Zustand 5.0.8 (управление состоянием)
- PrimeReact 10.9.7 (UI компоненты)
- Flowbite React 0.12.9 (UI компоненты)

---

## Установка и запуск

### Предварительные требования

- **Python:** 3.8 или выше
- **Node.js:** 16 или выше
- **npm** или **yarn**
- **Docker** и **Docker Compose** (опционально, для контейнеризации)

### Установка зависимостей

#### Backend

```bash
cd backend
pip install -r requirements.txt
```

**Зависимости:**
- `fastapi==0.104.1` - веб-фреймворк
- `uvicorn[standard]==0.24.0` - ASGI сервер
- `pydantic==2.5.0` - валидация данных
- `python-multipart==0.0.6` - обработка multipart данных

#### Frontend

```bash
cd frontend
npm install
```

### Запуск в режиме разработки

#### Backend

```bash
cd backend
python -m app.main
```

Или через uvicorn:

```bash
cd backend
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
```

Сервер будет доступен по адресу: **http://localhost:8000**

#### Frontend

```bash
cd frontend
npm run dev
```

Приложение будет доступно по адресу: **http://localhost:5173**

### Запуск через Docker

Из корневой директории проекта:

```bash
docker-compose up
```

Это запустит оба сервиса (backend и frontend) в контейнерах.

**Порты:**
- Backend: `http://localhost:8000`
- Frontend: `http://localhost:3000` (в Docker) или `http://localhost:5173` (в dev режиме)

---

## API документация

### Основные endpoints

#### Информация о сервере

```http
GET /
```

**Ответ:**
```json
{
  "message": "Эмулятор одноадресного процессора с архитектурой Фон-Неймана API"
}
```

#### Получить состояние эмулятора

```http
GET /api/state
```

**Ответ:**
```json
{
  "processor": {
    "accumulator": 0,
    "program_counter": 0,
    "instruction_register": 0,
    "instruction_register_asm": "",
    "flags": {
      "zero": false,
      "carry": false,
      "overflow": false,
      "negative": false
    },
    "current_command": "",
    "is_halted": false,
    "cycles": 0
  },
  "memory": {
    "ram": [0, 0, ...],
    "history": []
  },
  "source_code": "",
  "machine_code": [],
  "current_task": null
}
```

#### Компиляция исходного кода

```http
POST /api/compile
Content-Type: application/json

{
  "source_code": "LDI 10\nSTA 0x0100\nLDA 0x0100\nADD 0x0100\nHALT"
}
```

**Ответ (успех):**
```json
{
  "success": true,
  "machine_code": ["LDI 10", "STA 0x0100", "LDA 0x0100", "ADD 0x0100", "HALT"],
  "labels": {},
  "message": "Code compiled successfully"
}
```

**Ответ (ошибка):**
```json
{
  "success": false,
  "error": "Unknown instruction: INVALID",
  "message": "Compilation error: Unknown instruction: INVALID"
}
```

#### Загрузка задачи

```http
POST /api/load-task
Content-Type: application/json

{
  "task_id": 1
}
```

**Ответ:**
```json
{
  "success": true,
  "task_id": 1,
  "message": "Task loaded successfully",
  "state": { ... }
}
```

#### Выполнение программы

```http
POST /api/execute
Content-Type: application/json

{
  "task_id": 1,
  "step_by_step": false,
  "source_code": null
}
```

Или для пользовательского кода:

```http
POST /api/execute
Content-Type: application/json

{
  "task_id": null,
  "step_by_step": false,
  "source_code": "LDI 10\nHALT"
}
```

**Ответ:**
```json
{
  "success": true,
  "task_id": 1,
  "verification": {
    "task_id": 1,
    "success": true,
    "expected": 30,
    "actual": 30,
    "error": null
  },
  "state": { ... }
}
```

#### Выполнение одного шага

```http
POST /api/step
```

**Ответ:**
```json
{
  "success": true,
  "state": { ... },
  "message": "Step executed"
}
```

#### Сброс процессора

```http
POST /api/reset
```

**Ответ:**
```json
{
  "success": true,
  "message": "Процессор сброшен",
  "state": { ... }
}
```

#### Получить список задач

```http
GET /api/tasks
```

**Ответ:**
```json
[
  {
    "id": 1,
    "title": "Поиск максимума в массиве",
    "description": "Найти максимальный элемент в массиве целых чисел без знака..."
  },
  {
    "id": 2,
    "title": "Свертка двух массивов",
    "description": "Вычислить свертку двух массивов..."
  }
]
```

#### Получить информацию о задаче

```http
GET /api/tasks/{task_id}
```

#### Получить программу задачи

```http
GET /api/tasks/{task_id}/program
```

**Ответ:**
```json
{
  "task_id": 1,
  "program": "; Программа для поиска максимума в массиве...",
  "test_data": [3, 10, 20, 30]
}
```

#### Получить информацию об инструкции

```http
GET /api/instruction/{instruction}
```

**Пример:**
```http
GET /api/instruction/ADD
```

### Интерактивная документация

После запуска backend доступны:

- **Swagger UI:** http://localhost:8000/docs
- **ReDoc:** http://localhost:8000/redoc
- **OpenAPI JSON:** http://localhost:8000/openapi.json

---

## Примеры программ

### Пример 1: Простое сложение

```assembly
; Загрузка первого числа в аккумулятор
LDI 10          ; ACC = 10
STA 0x0100      ; сохранить в память[0x0100]

; Загрузка второго числа
LDI 20          ; ACC = 20
STA 0x0101      ; сохранить в память[0x0101]

; Сложение
LDA 0x0100      ; ACC = 10
ADD 0x0101      ; ACC = ACC + память[0x0101] = 10 + 20 = 30

; Остановка
HALT
```

**Результат:** ACC = 30

### Пример 2: Цикл с условием

```assembly
; Инициализация
LDI 0           ; ACC = 0
STA 0x0100      ; счетчик = 0
LDI 5           ; ACC = 5
STA 0x0101      ; предел = 5
LDI 0           ; ACC = 0
STA 0x0102      ; сумма = 0

LOOP_START:
; Проверка условия
LDA 0x0100      ; ACC = счетчик
CMP 0x0101      ; сравнить счетчик с пределом
JZ LOOP_END     ; если счетчик == предел, выйти

; Тело цикла: добавить счетчик к сумме
LDA 0x0102      ; ACC = сумма
ADD 0x0100      ; ACC = сумма + счетчик
STA 0x0102      ; сохранить новую сумму

; Увеличить счетчик
LDA 0x0100      ; ACC = счетчик
LDI 1           ; ACC = 1
STA 0x0103      ; сохранить 1
LDA 0x0100      ; ACC = счетчик
ADD 0x0103      ; ACC = счетчик + 1
STA 0x0100      ; сохранить новый счетчик

; Переход к началу цикла
JMP LOOP_START

LOOP_END:
LDA 0x0102      ; ACC = сумма
HALT
```

**Результат:** ACC = 0 + 1 + 2 + 3 + 4 = 10

### Пример 3: Работа с памятью

```assembly
; Загрузка данных в память
LDI 100         ; ACC = 100
STA 0x1000      ; память[0x1000] = 100

; Загрузка из памяти
LDA 0x1000      ; ACC = память[0x1000] = 100
STA 0x1001      ; сохранить в память[0x1001]

; Копирование значения
LDA 0x1000      ; ACC = память[0x1000] = 100
STA 0x1002      ; память[0x1002] = 100

HALT
```

**Результат:** ACC = 100, память[0x1000] = 100, память[0x1001] = 100, память[0x1002] = 100

### Пример 4: Условные переходы

```assembly
; Инициализация
LDI 10          ; ACC = 10
STA 0x0100      ; память[0x0100] = 10
LDI 5           ; ACC = 5
STA 0x0101      ; память[0x0101] = 5

; Сравнение
LDA 0x0100      ; ACC = 10
CMP 0x0101      ; сравнить 10 и 5 (ACC - память[0x0101])

; Условные переходы
JZ EQUAL        ; Не выполнится (результат != 0)
JNZ NOT_EQUAL   ; Выполнится (результат != 0)
JMP END

NOT_EQUAL:
LDI 1           ; ACC = 1
STA 0x0102      ; результат = 1
JMP END

EQUAL:
LDI 0           ; ACC = 0
STA 0x0102      ; результат = 0

END:
LDA 0x0102      ; ACC = результат
HALT
```

**Результат:** ACC = 1 (так как 10 != 5)

### Пример 5: Вычисление факториала

```assembly
; Вычисление факториала числа 5
LDI 5           ; ACC = 5
STA 0x0100      ; число = 5
LDI 1           ; ACC = 1
STA 0x0101      ; результат = 1
STA 0x0102      ; константа 1

FACT_LOOP:
LDA 0x0100      ; ACC = число
CMP 0x0102      ; сравнить число с 1
JZ FACT_END     ; если число == 1, выйти

; Умножение: результат = результат * число
LDA 0x0101      ; ACC = результат
MUL 0x0100      ; ACC = результат * число
STA 0x0101      ; сохранить новый результат

; Уменьшение числа
LDA 0x0100      ; ACC = число
SUB 0x0102      ; ACC = число - 1
STA 0x0100      ; сохранить новое число

JMP FACT_LOOP

FACT_END:
LDA 0x0101      ; ACC = результат
HALT
```

**Результат:** ACC = 5! = 120

---

## Использование эмулятора

### Интерфейс процессора

Веб-интерфейс предоставляет следующие компоненты:

#### 1. Панель процессора (ProcessorView)
- **Аккумулятор (ACC):** отображение текущего значения аккумулятора (единственный регистр для операций)
- **Счетчик команд (PC):** текущая позиция в программе
- **Регистр команд (IR):** текущая команда в машинном коде и ассемблере
- **Флаги состояния:** Z, C, V, N с визуальными индикаторами (зеленый/красный)
- **Циклы выполнения:** счетчик выполненных команд
- **Результаты задач:** отображение результатов выполнения задач (например, максимальный элемент для задачи 1)

#### 2. Редактор команд (CommandEditor)
- Поддержка синтаксиса ассемблера
- Подсветка синтаксиса
- Компиляция в реальном времени
- Отображение ошибок компиляции
- Нумерация строк
- **Вкладка "Примеры":** готовые примеры кода для задач
  - **Пример:** код с автоматической загрузкой данных из бэкенда
  - **Шаблон:** код с ручной инициализацией массива (можно редактировать)
  - Автоматическая загрузка данных задачи при выборе примера

#### 3. Просмотр памяти (MemoryView)
- Отображение содержимого ОЗУ
- История выполнения команд с фазами (FETCH, DECODE, EXECUTE)
- Отслеживание изменений регистров до и после выполнения команд
- Форматирование данных (десятичное/шестнадцатеричное)
- **Отображение с адресами:** данные отображаются в формате `[0x0100]=0x0003` (hex) и `[0x0100]=3` (dec)
- **Для задачи 1:** 
  - Отображение массива данных (0x0100-0x0103) с размером массива
  - Отображение переменной максимума (0x0411) на каждом шаге выполнения
  - Отображение значения аккумулятора (ACC) для текущего максимума
  - Корректное отображение состояния памяти на каждом шаге выполнения
- **Для задачи 2:** отображение команд программы из RAM (0x0000-0x00FF) и данных массивов A (0x0200-0x020A) и B (0x0300-0x030A)
- Постепенное появление данных в RAM по мере выполнения команд

#### 4. Панель управления (ControlPanel)
- **Шаг (Step):** выполнение одной команды
- **Выполнить (Run):** выполнение всей программы
- **Сброс (Reset):** сброс процессора в начальное состояние
- **Загрузить задачу:** выбор предустановленной задачи
- **Загрузить код:** загрузка пользовательского кода

#### 5. Панель задач (TaskPanel)
- Список доступных задач
- Описание задачи
- Загрузка задачи с тестовыми данными
- Верификация результата

### Рабочий процесс

1. **Загрузка программы:**
   - Введите код в редактор или выберите задачу
   - Код автоматически компилируется
   - При ошибках компиляции они отображаются в редакторе

2. **Выполнение:**
   - **Пошагово:** нажимайте "Шаг" для выполнения одной команды (с фазами FETCH, DECODE, EXECUTE)
   - **Полностью:** нажмите "Выполнить" для выполнения всей программы
   - Наблюдайте за изменениями аккумулятора (ACC), флагов и памяти

3. **Отладка:**
   - Используйте пошаговое выполнение для отслеживания изменений
   - Проверяйте значение аккумулятора (ACC) после каждой команды
   - Анализируйте историю выполнения в MemoryView с фазами выполнения команд

4. **Сброс:**
   - Используйте кнопку "Сброс" для возврата к начальному состоянию
   - Все регистры, флаги и память сбрасываются

---

## Особенности реализации

### Архитектура фон Неймана

Эмулятор реализует архитектуру фон Неймана, где команды и данные хранятся в одном ОЗУ:

- **Задача 1:** Данные массива хранятся в RAM начиная с адреса 0x0100
- **Задача 2:** 
  - Команды программы хранятся в RAM начиная с адреса 0x0000
  - Данные массивов A и B хранятся в RAM начиная с адресов 0x0200 и 0x0300 соответственно
  - Команды кодируются в машинный код и записываются в RAM при загрузке задачи

### Постепенная загрузка данных

Для задач 1 и 2 реализована постепенная загрузка данных в RAM:

- **При загрузке задачи:** память очищается, данные не записываются
- **При выполнении команд:** данные появляются в RAM постепенно, по одному элементу за каждую фазу execute
- **Для задачи 1:** 
  - После 1-го execute записывается размер массива (0x0100)
  - После 2-го execute записывается первый элемент (0x0101)
  - После 3-го execute записывается второй элемент (0x0102)
  - И так далее
- **Для задачи 2:** аналогично, данные массивов A и B записываются постепенно

Это позволяет наблюдать процесс загрузки данных в реальном времени и демонстрирует работу архитектуры фон Неймана.

### Ассемблер

**Двухпроходная компиляция:**

1. **Первый проход:**
   - Парсинг исходного кода
   - Построение таблицы меток
   - Проверка синтаксиса

2. **Второй проход:**
   - Подстановка адресов меток
   - Генерация машинного кода
   - Финальная проверка

**Поддерживаемые форматы:**
- Десятичные числа: `100`, `-50`
- Шестнадцатеричные: `0x1000`, `0xFF`
- Двоичные: `0b1010`
- Метки: `LOOP_START:`, `END:`

**Обработка ошибок:**
- Неизвестные инструкции
- Неверное количество операндов
- Неопределенные метки
- Некорректные адреса памяти
- Выход за границы памяти (0x0000-0x1FFF)

### Процессор

**Выполнение команд:**
- Пошаговое выполнение с тремя фазами: FETCH, DECODE, EXECUTE
- Обновление состояния после каждой фазы
- Обновление флагов после каждой операции
- Проверка переполнения для 16-битных чисел (-32768..32767)
- Обработка ошибок выполнения (деление на ноль, выход за границы памяти)
- **Постепенная загрузка данных задач:** данные задач 1 и 2 записываются в RAM постепенно после каждой фазы execute, начиная с первого execute

**Управление памятью:**
- Проверка границ при доступе к памяти
- История изменений для отладки
- Инициализация памяти нулями
- **Архитектура фон Неймана (задача 2):** команды программы хранятся в RAM начиная с адреса 0x0000
- **Постепенная загрузка данных:** для задач 1 и 2 данные появляются в RAM постепенно, по одному элементу за каждую команду execute, что позволяет наблюдать процесс загрузки данных в реальном времени

**Флаги состояния:**
- Автоматическое обновление после арифметических операций
- Использование флагов в условных переходах
- Визуальная индикация в интерфейсе

### Интерфейс

**Реактивное обновление:**
- Автоматическое обновление состояния при изменениях
- Анимации изменений регистров и флагов
- Поддержка разных форматов отображения (десятичный/шестнадцатеричный)

**Адаптивный дизайн:**
- Работа на разных размерах экрана
- Современный UI с использованием PrimeReact и Flowbite
- Плавные анимации и переходы

---

## Отладка и диагностика

### Логирование

Backend выводит детальные логи:
- Выполнение команд
- Изменения регистров
- Операции с памятью
- Ошибки выполнения

**Пример логов:**
```
DEBUG _parse_operand: operand_str='[0x1000]', inner='0x1000', addr=0x1000, mode=DIRECT
DEBUG _get_operand_value DIRECT: operand=0x1000, value=0x0007, memory[0x1000]=0x0007
```

### Валидация

**Проверки на этапе компиляции:**
- Корректность команд
- Количество операндов
- Существование меток
- Валидность регистров

**Проверки во время выполнения:**
- Валидация адресов памяти
- Контроль переполнения
- Проверка деления на ноль
- Верификация результатов задач

### Типичные ошибки

1. **"Unknown instruction"**
   - Проверьте правильность написания команды
   - Убедитесь, что команда поддерживается

2. **"Invalid address"**
   - Проверьте корректность адреса памяти
   - Убедитесь, что адрес в диапазоне 0x0000-0x1FFF

3. **"Division by zero"**
   - Проверьте значение делителя перед делением

4. **"OUT_OF_BOUNDS"**
   - Убедитесь, что адрес памяти в диапазоне 0x0000-0x1FFF

5. **"Undefined label"**
   - Проверьте наличие метки в коде
   - Убедитесь в правильности написания метки

---

## Требования к системе

### Минимальные требования

- **Python:** 3.8+
- **Node.js:** 16+
- **RAM:** 4 GB
- **Свободное место:** 1 GB
- **ОС:** Windows 10+, Linux, macOS

### Рекомендуемые требования

- **Python:** 3.11+
- **Node.js:** 18+
- **RAM:** 8 GB
- **Свободное место:** 2 GB
- **Браузер:** Chrome 90+, Firefox 88+, Safari 14+, Edge 90+

---

## Troubleshooting

### Проблемы с запуском

#### Backend не запускается

1. **Проверьте установку зависимостей:**
   ```bash
   cd backend
   pip install -r requirements.txt
   ```

2. **Проверьте версию Python:**
   ```bash
   python --version  # Должно быть 3.8+
   ```

3. **Проверьте занятость порта 8000:**
   ```bash
   # Windows
   netstat -ano | findstr :8000
   
   # Linux/macOS
   lsof -i :8000
   ```

#### Frontend не запускается

1. **Проверьте установку зависимостей:**
   ```bash
   cd frontend
   npm install
   ```

2. **Проверьте версию Node.js:**
   ```bash
   node --version  # Должно быть 16+
   ```

3. **Очистите кэш:**
   ```bash
   rm -rf node_modules package-lock.json
   npm install
   ```

#### CORS ошибки

Если возникают CORS ошибки, убедитесь, что:
- Backend запущен на порту 8000
- Frontend запущен на порту 5173
- В `main.py` настроены правильные `allow_origins`

#### Docker проблемы

1. **Проверьте запуск Docker:**
   ```bash
   docker --version
   docker-compose --version
   ```

2. **Пересоберите образы:**
   ```bash
   docker-compose build --no-cache
   docker-compose up
   ```

### Проблемы с выполнением программ

1. **Программа не выполняется:**
   - Проверьте наличие команды `HALT` в конце
   - Убедитесь, что код скомпилирован без ошибок

2. **Неправильные результаты:**
   - Используйте пошаговое выполнение для отладки
   - Проверяйте значения регистров после каждой команды
   - Убедитесь в правильности алгоритма

3. **Бесконечный цикл:**
   - Проверьте условия выхода из цикла
   - Убедитесь, что счетчик цикла изменяется

---

## Лицензия

Проект разработан в учебных целях для демонстрации принципов работы процессора и системы команд.

---

## Поддержка

При возникновении проблем:

1. Проверьте установлены ли все зависимости
2. Убедитесь, что оба сервера запущены (backend и frontend)
3. Проверьте отсутствие конфликтов портов
4. Изучите примеры программ в разделе "Примеры программ"
5. Обратитесь к документации API: http://localhost:8000/docs

---

## Дополнительные ресурсы

### Полезные ссылки

- [FastAPI документация](https://fastapi.tiangolo.com/)
- [React документация](https://react.dev/)
- [TypeScript документация](https://www.typescriptlang.org/)
- [RISC архитектура](https://ru.wikipedia.org/wiki/RISC)

### Структура проекта

```
assembly_emulator_v9/
├── backend/              # Backend приложение
│   ├── app/              # Основной код приложения
│   ├── requirements.txt  # Python зависимости
│   └── Dockerfile        # Docker образ
├── frontend/             # Frontend приложение
│   ├── src/              # Исходный код
│   ├── package.json      # Node.js зависимости
│   └── Dockerfile        # Docker образ
├── docker-compose.yml     # Docker Compose конфигурация
└── README.md             # Этот файл
```

---

**Версия:** 9.0.0  
**Репозиторий:** [https://github.com/ChaoticPost/assembly_emulator_v9](https://github.com/ChaoticPost/assembly_emulator_v9)  
**Последнее обновление:** 2025

### История изменений

#### Версия 9.0.0 (2024)
- ✅ Реализована одноадресная архитектура Фон-Неймана с одним аккумулятором (ACC)
- ✅ Обновлена система команд для одноадресной архитектуры
- ✅ Реализована архитектура фон Неймана (команды и данные в единой памяти)
- ✅ Добавлена постепенная загрузка данных для задач 1 и 2
- ✅ Улучшено отображение данных в MemoryView с адресами (формат `[0x0100]=0x0003`)
- ✅ Добавлено отображение команд из RAM для задачи 2
- ✅ Реализована система фаз выполнения (FETCH, DECODE, EXECUTE)
- ✅ Улучшена визуализация состояния процессора и памяти
- ✅ Обновлена задача 1: поиск максимума в массиве (вместо суммы)
- ✅ Добавлена поддержка таблицы переходов для работы с массивами
- ✅ Упрощен пример задачи 1: массив из 3 элементов [3, 10, 20, 30] для быстрой проверки
- ✅ Оптимизирован код программы для работы с 3 элементами (индексы 2 и 3)
- ✅ Добавлена автоматическая загрузка данных при выборе примера из бэкенда
- ✅ Улучшено отображение переменной максимума (0x0411) в блоке "Пошаговое выполнение программы"
- ✅ Обновлены примеры и шаблоны кода для задачи 1 с ручной и автоматической инициализацией
